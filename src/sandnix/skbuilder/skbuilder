#! /usr/bin/env python2
# -*- coding: utf-8 -*-

'''
	  Copyright 2016,暗夜幽灵 <darknightghost.cn@gmail.com>
	  This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	  You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import sys
import os
import struct
import multiboot
import elf
import kheader

def main():
	#Get args
	args = scan_args()
	try:
		kernel_path = args["k"]
		header_path = args["h"]
		output_path = args["o"]
		load_addr = int(args["l"],16)
		vload_addr = int(args["v"],16)
		arch = args["a"]
	except KeyError:
		usage()
		return -1
		
	offset = load_addr - vload_addr
	
	#Header
	header = multiboot.multiboot_header(header_path)
	header.set_header_addr(load_addr)
	
	#Kernel
	kernel = elf.elf(kernel_path)
	
	fout = open(output_path,"wb")
	print("\nOutput file \"%s\" opened."%(output_path))
	
	#Get segments
	entry = kernel.get_entry() + offset
	segments = kernel.get_program_headers()
	khdr = None
	
	text_begin = 0
	text_end = 0
	data_begin = 0
	data_end = 0
	file_end = 0
	for t in segments:
		if entry >= t.get_vaddr() + offset and entry <= t.get_vaddr() + t.get_memsz() + offset:
			text_begin = t.get_vaddr() + offset
			text_end = t.get_vaddr() + t.get_memsz() + offset
		else:
			data_begin = t.get_vaddr() + offset
			data_end = t.get_vaddr() + t.get_memsz() + offset

		if file_end < t.get_vaddr() + t.get_filesz() - vload_addr:
			file_end = t.get_vaddr() + t.get_filesz() - vload_addr
	
	fout.seek(0,0)
	fout.write(b'\x00' * file_end)
	fout.seek(0,0)
	
	#Write header
	print("\nWriting header...")
	print("Load address : 0x%0.8x."%(text_begin))
	header.set_load_addr(text_begin)
	print("Load end address : 0x%0.8x."%(file_end + load_addr))
	header.set_load_end_addr(file_end + load_addr)
	print("Bss end address : 0x%0.8x."%(data_end))
	header.set_bss_end_addr(data_end)
	print("Entery address : 0x%0.8x."%(entry))
	header.set_entry_addr(entry)
	header.write(fout)

	#Write segments
	print("\nWriting segments...")
	for t in segments:
		if entry >= t.get_vaddr() + offset and entry <= t.get_vaddr() + t.get_memsz() + offset:
			print("\nCode segment :")
			khdr = kheader.kheader(t.get_data())
			khdr.set_text_begin(text_begin)
			khdr.set_text_end(text_end)
			khdr.set_data_begin(data_begin)
			khdr.set_data_end(data_end)
			data = khdr.get_data()
		else:
			print("\nData segment :")
			data = t.get_data()
		
		print("Address : 0x%0.8x"%(t.get_vaddr() + offset))
		print("File offset : 0x%0.8x"%(t.get_vaddr() - vload_addr))
		print("Mem size : 0x%0.8x"%(t.get_memsz()))
		print("File size : 0x%0.8x"%(t.get_filesz()))
		fout.seek(t.get_vaddr() - vload_addr,0)
		fout.write(data)
	
	fout.close()
	print("Kernel image \"%s\" written."%(os.path.abspath(output_path)))
	return 0

def usage():
	print("Usage:\n\tskconfig -a arch -h header -k kernel -o output -l load-address -v virtual-load-address")
	return

def scan_args():
	arg_list = sys.argv
	ret = {}
	new_arg = ""
	type = sys.getfilesystemencoding()
	
	for s in arg_list:
		if s == "--help":
			usage()
			exit(0)
		elif s[0] == "-":
			new_arg = s[1:]
		else:
			ret[new_arg] = s.decode(type).encode('utf-8')
	return ret

ret = main()
exit(ret)

